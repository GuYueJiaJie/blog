[114.二叉树展开为链表](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/submissions/)

[力扣 JS 题解。](https://github.com/GuYueJiaJie/blog/blob/master/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/README.md)

## 方法一 原地

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {void} Do not return anything, modify root in-place instead.
 */
var flatten = function(root) {
  let node = root;
  while (node !== null) {
    if (node.left !== null) {
      // 如果左子树不为空，就找到左子树的最右节点
      let right = node.left;
      while (right.right !== null) right = right.right;
      // 然后将根节点的右节点拼接到最右节点的右节点上
      right.right = node.right;
      // 把根节点的右子节点设置为根节点的左子节点
      node.right = node.left;
      // 左子节点设置为null
      node.left = null;
    }
    // 重置node
    node = node.right;
  }
  return root;
};
```

## 方法二 先序遍历

此方法不满足题目要求，并非原地。

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {void} Do not return anything, modify root in-place instead.
 */
var flatten = function(root) {
  if (root === null) return null;
  let head = new TreeNode(null);
  head.right = root;
  let pre = head;
  let stack = [root];
  while (stack.length > 0) {
    root = stack.pop();
    pre.right = root;
    pre.left = null;
    root.right && stack.push(root.right);
    root.left && stack.push(root.left);
    pre = root;
  }
  return head.right;
};
```
