[96.不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/submissions/)

[力扣 JS 题解。](https://github.com/GuYueJiaJie/blog/tree/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95)

[优质题解](https://leetcode-cn.com/problems/unique-binary-search-trees/solution/bu-tong-de-er-cha-sou-suo-shu-by-leetcode/)

## 方法一

每一个树的构成都可以分为左子树和右子树，所以以 i 为根节点的二叉搜索树种类的个数可以分解为子问题：左子树的种类 乘 右子树的种类。

左子树的节点范围为：1...i-1。  
右子树的节点范围为：i+1...n。

那么就可以把同样的问题转接到左子树和有字数上。

时间复杂度：`O(n²)`

空间复杂度：`O(n)`

```javascript
/**
 * @param {number} n
 * @return {number}
 */
var numTrees = function (n) {
    // res[i]表示以1...i为节点组成的二叉搜索树的种类
    let res = new Array(n + 1).fill(0);
    res[0] = 1;
    res[1] = 1;

    // res[1]已经确定，因此从2开始
    for (let i = 2; i <= n; i++) {
        // j表示分别从1为根节点至i为根节点
        for (let j = 1; j <= i; j++) {
            res[i] += res[j - 1] * res[i - j];
        }
    }
    return res[n];
};
```

## 方法二 [卡塔兰数](https://baike.baidu.com/item/catalan/7605685?fr=aladdin)

```javascript
/**
 * @param {number} n
 * @return {number}
 */
var numTrees = function (n) {
    let res = 1;
    for (let i = 0; i < n; i++) {
        res = (2 * res * (2 * i + 1)) / (i + 2);
    }
    return res;
};
```
