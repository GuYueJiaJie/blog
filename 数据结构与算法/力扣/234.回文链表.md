[234.回文链表]()

[力扣 JS 题解。](https://github.com/GuYueJiaJie/blog/tree/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95)

题目要求时间复杂度为`O(n)`，空间复杂度为`O(1)`，那么新建数据结构用于存储数据的思路便不可取，因此可以考虑对原始链表进行操作。

在判断字符串是否是回文字符串时，会选取双指针进行头尾比较然后向中间靠拢，但是单链表没有向前的指针，因此从后向前的比较方式不可取，那么可以考虑从前向后进行比较。

因此，本题可以分解为三步进行：

1. 设置双指针找到链表中点。
2. 对前半部分链表进行反转。
3. 根据链表节点总数的奇偶性，选取前后两部分链表的开始节点，然后开始比较。

也可以考虑对后半部分链表进行反装，一样的思路。

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @return {boolean}
 */
var isPalindrome = function (head) {
    // 首先找到链表的中点
    if (head === null) true;
    let middle = head,
        end = head;
    let num = 0; // 链表节点的总个数
    while (end !== null) {
        num++;
        end = end.next;
        if ((num & 1) === 0) {
            middle = middle.next;
        }
    }
    // 然后反转前一部分链表
    let pre = null,
        cur = head,
        next;
    while (cur !== middle) {
        next = cur.next;
        cur.next = pre;
        pre = cur;
        cur = next;
    }
    // 最后根绝链表总数的奇偶性不同选取左右部分的起始节点，然后开始遍历
    let leftStart = pre,
        rightStart;
    if (num & 1) {
        // 如果链表节点个数是奇数，那么middle指向的是链表的中点
        rightStart = middle.next;
    } else {
        // 如果链表节点个数是偶数，那么middle指向的是后半部第一个节点
        rightStart = middle;
    }
    while (leftStart !== null && rightStart !== null) {
        if (leftStart.val !== rightStart.val) {
            return false;
        }
        leftStart = leftStart.next;
        rightStart = rightStart.next;
    }
    return true;
};
```
