[200.岛屿数量](https://leetcode-cn.com/problems/number-of-islands/submissions/)

[力扣 JS 题解。](https://github.com/GuYueJiaJie/blog/tree/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95)

本题[优质题解](https://leetcode-cn.com/problems/number-of-islands/solution/dfs-bfs-bing-cha-ji-python-dai-ma-java-dai-ma-by-l/)参考。

## 方法一 DFS

```javascript
/**
 * @param {character[][]} grid
 * @return {number}
 */
var numIslands = function (grid) {
    if (!Array.isArray(grid) || grid.length <= 0 || grid[0].length <= 0) return 0;
    let rows = grid.length,
        cols = grid[0].length;
    let marked = new Array(rows);
    // 注意这里fill有坑，不能连续两个fill初始化二维数组
    for (let i = 0; i < marked.length; i++) {
        marked[i] = new Array(cols).fill(false);
    }
    let direction = [
        [-1, 0],
        [0, 1],
        [1, 0],
        [0, -1],
    ]; // 用来记录移动的四个方向
    let count = 0;
    for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
            if (!marked[i][j] && grid[i][j] === '1') {
                count++;
                dfs(i, j);
            }
        }
    }
    function dfs(i, j) {
        marked[i][j] = true;
        for (let k = 0; k < direction.length; k++) {
            let newI = i + direction[k][0];
            let newJ = j + direction[k][1];
            if (isValid(newI, newJ) && !marked[newI][newJ] && grid[newI][newJ] === '1') {
                dfs(newI, newJ);
            }
        }
    }
    function isValid(i, j) {
        return i >= 0 && i < rows && j >= 0 && j < cols;
    }
    return count;
};
```

## 方法二 BFS

大致思路与 DFS 相同，区别在于将 DFS 转化为 BFS。

```javascript
/**
 * @param {character[][]} grid
 * @return {number}
 */
var numIslands = function (grid) {
    if (!Array.isArray(grid) || grid.length <= 0 || grid[0].length <= 0) return 0;
    let rows = grid.length,
        cols = grid[0].length;
    let marked = new Array(rows);
    for (let i = 0; i < marked.length; i++) {
        marked[i] = new Array(cols).fill(false);
    }
    let direction = [
        [-1, 0],
        [0, 1],
        [1, 0],
        [0, -1],
    ]; // 用来记录移动的四个方向
    let count = 0;
    let queue = [];
    for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
            if (!marked[i][j] && grid[i][j] === '1') {
                count++;
                queue.push([i, j]);
                marked[i][j] = true;
                while (queue.length > 0) {
                    let [curI, curJ] = queue.pop();
                    for (let k = 0; k < direction.length; k++) {
                        let newI = curI + direction[k][0];
                        let newJ = curJ + direction[k][1];
                        if (
                            isValid(newI, newJ) &&
                            !marked[newI][newJ] &&
                            grid[newI][newJ] === '1'
                        ) {
                            queue.push([newI, newJ]);
                            marked[newI][newJ] = true;
                        }
                    }
                }
            }
        }
    }

    function isValid(i, j) {
        return i >= 0 && i < rows && j >= 0 && j < cols;
    }
    return count;
};
```
